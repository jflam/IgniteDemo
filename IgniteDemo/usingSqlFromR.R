
# Samples of SQL Server integration

# RTVS connection strings are stored in auto-generated Settings.R file. This file
# must be sourced by any R script that wants to use the connection string.

source("Settings.R")

# Sourcing this file ensures that any dependencies that might need to be installed
# within this workspace are present before we attempt to use those dependencies.

source("dependencies.R")

# 1. Simple query using RODBC, returning results as an R dataframe

library(RODBC)
conn <- odbcDriverConnect(connection = dbConnection)

# We have two ways of defining the SQL query. The first is as an inline string:

sql <- "SELECT COUNT( * ) FROM nyctaxi_sample"
df <- sqlQuery(conn, sql)
print(
    paste(
        "There are", 
        df[[1, 1]], 
        "rows in the nyctaxi_sample table."
    )
)

# The second way of defining the SQL query is by referencing an external file.
# This has the advantage of allowing the user to use the built-in Visual Studio
# SQL tooling to write and test their query before using it from within their 
# R script.
#
# The code that is used to reference the SQL file in the RTVS project was auto
# generated by the tool by dragging and dropping the filename from the Solution
# Explorer into the editor. I manually reformatted the code to make it easier to
# read in this sample, but the content is identical.

sql <- 
    iconv(
        paste(
            readLines(
                'c:/users/jflam/src/ignitedemo/ignitedemo/computetripdistance.sql', 
                encoding = 'UTF-8', 
                warn = FALSE
            ),
            collapse = '\n'
        ),
        from = 'UTF-8', 
        to = 'ASCII', 
        sub = ''
    )

df <- sqlQuery(conn, sql)

# You should inspect df using the Variable Explorer, as there are a large number
# of results (>16K rows)

# 2. Simple query using Microsoft R Client, returning results as an R dataframe

# The Microsoft R Client libraries contains a set of functions that allow you to
# send SQL commands to SQL Server, and generate result sets that exist only on the
# SQL Server machine. You can also optionally download the result sets to the client
# as well. This sample generates the initial result set on the server, using 
# the RxSqlServerData function, and then downloads it to the client for inspection
# using the rxImport and rxDataStep functions.

library(RevoScaleR)

# Use the local compute context

rxSetComputeContext("local")

# Define the query

top10Data <- RxSqlServerData(
    sqlQuery = "select top 10 * from nyctaxi_sample",
    connectionString = dbConnection)

# Use the rxImport function to move the data from the server to the client

df <- rxImport(
    top10Data, 
    reportProgress = 0)

# 3. Simple query using Microsoft R Services for SQL Server 2016, returning
# result as a plot from SQL Server. In this case, we generate a result set entirely
# on the server, and then use the rxHistogram function to compute and plot a histogram
# on the server, and stream the resulting plot back to the client for display.
#
# You can do an experiment to validate for yourself that the data is not being streamed
# back to the client by changing the value used in the SELECT TOP clause, and re-computing
# the histogram.

sqlShareDir <- paste("C:\\AllShare\\", Sys.getenv("USERNAME"), sep = "")
sqlWait <- TRUE
sqlConsoleOutput <- FALSE

cc <- RxInSqlServer(
    connectionString = dbConnection,
    shareDir = sqlShareDir,
    wait = sqlWait,
    consoleOutput = sqlConsoleOutput)

rxSetComputeContext(cc)

faresHistogramQuery <- "SELECT TOP 10000 fare_amount FROM nyctaxi_sample"

faresHistogramDataSource <- RxSqlServerData(
    sqlQuery = faresHistogramQuery,
    connectionString = dbConnection,
    rowsPerRead = 500)

system.time(
    rxHistogram(
        ~ fare_amount,
        data = faresHistogramDataSource,
        title = "Fare Amount Histogram"
    )
)

# 4. Performance test between RODBC and RevoScaleR libraries
# Returns ~16K rows

# Read in the query from the ComputeTripDistance.sql file

sql <- 
iconv(
        paste(
            readLines(
                'c:/users/jflam/src/ignitedemo/ignitedemo/computetripdistance.sql', 
                encoding = 'UTF-8', 
                warn = FALSE
            ),
            collapse = '\n'
        ),
        from = 'UTF-8', 
        to = 'ASCII', 
        sub = ''
    )

# Run the query using RODBC

library(RODBC)

source("Settings.R")
conn <- odbcDriverConnect(connection = dbConnection)

start.time <- proc.time()
df1 <- sqlQuery(conn, sql)
used.time <- proc.time() - start.time

print(
    paste(
        "It takes CPU Time=", 
        round(used.time[1] + used.time[2], 2),
        "seconds, Elapsed Time=", 
        round(used.time[3], 2), 
        "seconds to generate features."
    )
)

# This is using RevoScaleR libraries

library(RevoScaleR)
rxSetComputeContext("local")

computedDistanceDataSource <- RxSqlServerData(
    sqlQuery = sql,
    connectionString = dbConnection)

start.time <- proc.time()

df2 <- rxImport(
    computedDistanceDataSource,
    reportProgress = 0)

used.time <- proc.time() - start.time

print(
    paste(
        "It takes CPU Time=", 
        round(used.time[1] + used.time[2], 2),
        "seconds, Elapsed Time=", 
        round(used.time[3], 2), 
        "seconds to generate features."
    )
)

# Assert that we have the same result set dimensions -- this should 
# print TRUE TRUE, indicating that both dimensions are the same

print(dim(df1) == dim(df2))