
# Samples of SQL Server integration

# RTVS connection strings are stored in auto-generated Settings.R file. This file
# must be sourced by any R script that wants to use the connection string.

source("Settings.R")

# Sourcing this file ensures that any dependencies that might need to be installed
# within this workspace are present before we attempt to use those dependencies.

source("dependencies.R")

# 1. Simple query using RODBC, returning results as an R dataframe

library(RODBC)
conn <- odbcDriverConnect(connection = dbConnection)

# We have two ways of defining the SQL query. The first is as an inline string:

sql <- "SELECT COUNT( * ) FROM nyctaxi_sample"
df <- sqlQuery(conn, sql)
print(
    paste(
        "There are", 
        df[[1, 1]], 
        "rows in the nyctaxi_sample table."
    )
)

# The second way of defining the SQL query is by referencing an external file.
# This has the advantage of allowing the user to use the built-in Visual Studio
# SQL tooling to write and test their query before using it from within their 
# R script.
#
# The code that is used to reference the SQL file in the RTVS project was auto
# generated by the tool by dragging and dropping the filename from the Solution
# Explorer into the editor. I manually reformatted the code to make it easier to
# read in this sample, but the content is identical.

sql <- 
    iconv(
        paste(
            readLines(
                'c:/users/jflam/src/ignitedemo/ignitedemo/computetripdistance.sql', 
                encoding = 'UTF-8', 
                warn = FALSE
            ),
            collapse = '\n'
        ),
        from = 'UTF-8', 
        to = 'ASCII', 
        sub = ''
    )

df <- sqlQuery(conn, sql)

# You should inspect df using the Variable Explorer, as there are a large number
# of results (>16K rows)

# 2. Simple query using Microsoft R Client, returning results as an R dataframe

# The Microsoft R Client libraries contains a set of functions that allow you to
# send SQL commands to SQL Server, and generate result sets that exist only on the
# SQL Server machine. You can also optionally download the result sets to the client
# as well. This sample generates the initial result set on the server, using 
# the RxSqlServerData function, and then downloads it to the client for inspection
# using the rxImport and rxDataStep functions.

library(RevoScaleR)

top10Data <- RxSqlServerData(
    sqlQuery = "select top 10 * from nyctaxi_sample",
    connectionString = dbConnection)

# The local compute context is used for rxImport and rxDataStep functions.

rxSetComputeContext("local")

localFile <- file.path(tempdir(), "sql_data.xdf")
rxImport(
    inData = top10Data,
    outFile = localFile,
    overwrite = TRUE,
    reportProgress = 0)

df <- rxDataStep(
    localFile,
    reportProgress = 0)

# 3. Simple query using Microsoft R Services for SQL Server 2016, returning
# result as a plot from SQL Server. In this case, we generate a result set entirely
# on the server, and then use the rxHistogram function to compute and plot a histogram
# on the server, and stream the resulting plot back to the client for display.
#
# You can do an experiment to validate for yourself that the data is not being streamed
# back to the client by changing the value used in the SELECT TOP clause, and re-computing
# the histogram.

sqlShareDir <- paste("C:\\AllShare\\", Sys.getenv("USERNAME"), sep = "")
sqlWait <- TRUE
sqlConsoleOutput <- FALSE

cc <- RxInSqlServer(
    connectionString = dbConnection,
    shareDir = sqlShareDir,
    wait = sqlWait,
    consoleOutput = sqlConsoleOutput)

rxSetComputeContext(cc)

faresHistogramQuery <- "SELECT TOP 10000 fare_amount FROM nyctaxi_sample"

faresHistogramDataSource <- RxSqlServerData(
    sqlQuery = faresHistogramQuery,
    connectionString = dbConnection,
    rowsPerRead = 500)

system.time(
    rxHistogram(
        ~ fare_amount,
        data = faresHistogramDataSource,
        title = "Fare Amount Histogram"
    )
)